Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DROP
    DUP
    LPAREN
    OVER
    RPAREN
    SWAP

Grammar

Rule 0     S' -> axioma
Rule 1     axioma -> axioma ponto
Rule 2     axioma -> expression
Rule 3     ponto -> PONTO
Rule 4     expression -> int int operationi
Rule 5     expression -> float float operationf
Rule 6     expression -> float int operationf
Rule 7     expression -> int float operationf
Rule 8     int -> INT
Rule 9     float -> FLOAT
Rule 10    operationi -> PLUS
Rule 11    operationi -> MINUS
Rule 12    operationi -> TIMES
Rule 13    operationi -> DIVIDE
Rule 14    operationi -> MOD
Rule 15    operationf -> PLUS
Rule 16    operationf -> MINUS
Rule 17    operationf -> TIMES
Rule 18    operationf -> DIVIDE

Terminals, with rules where they appear

DIVIDE               : 13 18
DROP                 : 
DUP                  : 
FLOAT                : 9
INT                  : 8
LPAREN               : 
MINUS                : 11 16
MOD                  : 14
OVER                 : 
PLUS                 : 10 15
PONTO                : 3
RPAREN               : 
SWAP                 : 
TIMES                : 12 17
error                : 

Nonterminals, with rules where they appear

axioma               : 1 0
expression           : 2
float                : 5 5 6 7
int                  : 4 4 6 7
operationf           : 5 6 7
operationi           : 4
ponto                : 1

Parsing method: LALR

state 0

    (0) S' -> . axioma
    (1) axioma -> . axioma ponto
    (2) axioma -> . expression
    (4) expression -> . int int operationi
    (5) expression -> . float float operationf
    (6) expression -> . float int operationf
    (7) expression -> . int float operationf
    (8) int -> . INT
    (9) float -> . FLOAT

    INT             shift and go to state 5
    FLOAT           shift and go to state 6

    axioma                         shift and go to state 1
    expression                     shift and go to state 2
    int                            shift and go to state 3
    float                          shift and go to state 4

state 1

    (0) S' -> axioma .
    (1) axioma -> axioma . ponto
    (3) ponto -> . PONTO

    PONTO           shift and go to state 8

    ponto                          shift and go to state 7

state 2

    (2) axioma -> expression .

    PONTO           reduce using rule 2 (axioma -> expression .)
    $end            reduce using rule 2 (axioma -> expression .)


state 3

    (4) expression -> int . int operationi
    (7) expression -> int . float operationf
    (8) int -> . INT
    (9) float -> . FLOAT

    INT             shift and go to state 5
    FLOAT           shift and go to state 6

    int                            shift and go to state 9
    float                          shift and go to state 10

state 4

    (5) expression -> float . float operationf
    (6) expression -> float . int operationf
    (9) float -> . FLOAT
    (8) int -> . INT

    FLOAT           shift and go to state 6
    INT             shift and go to state 5

    float                          shift and go to state 11
    int                            shift and go to state 12

state 5

    (8) int -> INT .

    INT             reduce using rule 8 (int -> INT .)
    FLOAT           reduce using rule 8 (int -> INT .)
    PLUS            reduce using rule 8 (int -> INT .)
    MINUS           reduce using rule 8 (int -> INT .)
    TIMES           reduce using rule 8 (int -> INT .)
    DIVIDE          reduce using rule 8 (int -> INT .)
    MOD             reduce using rule 8 (int -> INT .)


state 6

    (9) float -> FLOAT .

    FLOAT           reduce using rule 9 (float -> FLOAT .)
    INT             reduce using rule 9 (float -> FLOAT .)
    PLUS            reduce using rule 9 (float -> FLOAT .)
    MINUS           reduce using rule 9 (float -> FLOAT .)
    TIMES           reduce using rule 9 (float -> FLOAT .)
    DIVIDE          reduce using rule 9 (float -> FLOAT .)


state 7

    (1) axioma -> axioma ponto .

    PONTO           reduce using rule 1 (axioma -> axioma ponto .)
    $end            reduce using rule 1 (axioma -> axioma ponto .)


state 8

    (3) ponto -> PONTO .

    PONTO           reduce using rule 3 (ponto -> PONTO .)
    $end            reduce using rule 3 (ponto -> PONTO .)


state 9

    (4) expression -> int int . operationi
    (10) operationi -> . PLUS
    (11) operationi -> . MINUS
    (12) operationi -> . TIMES
    (13) operationi -> . DIVIDE
    (14) operationi -> . MOD

    PLUS            shift and go to state 14
    MINUS           shift and go to state 15
    TIMES           shift and go to state 16
    DIVIDE          shift and go to state 17
    MOD             shift and go to state 18

    operationi                     shift and go to state 13

state 10

    (7) expression -> int float . operationf
    (15) operationf -> . PLUS
    (16) operationf -> . MINUS
    (17) operationf -> . TIMES
    (18) operationf -> . DIVIDE

    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    TIMES           shift and go to state 22
    DIVIDE          shift and go to state 23

    operationf                     shift and go to state 19

state 11

    (5) expression -> float float . operationf
    (15) operationf -> . PLUS
    (16) operationf -> . MINUS
    (17) operationf -> . TIMES
    (18) operationf -> . DIVIDE

    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    TIMES           shift and go to state 22
    DIVIDE          shift and go to state 23

    operationf                     shift and go to state 24

state 12

    (6) expression -> float int . operationf
    (15) operationf -> . PLUS
    (16) operationf -> . MINUS
    (17) operationf -> . TIMES
    (18) operationf -> . DIVIDE

    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    TIMES           shift and go to state 22
    DIVIDE          shift and go to state 23

    operationf                     shift and go to state 25

state 13

    (4) expression -> int int operationi .

    PONTO           reduce using rule 4 (expression -> int int operationi .)
    $end            reduce using rule 4 (expression -> int int operationi .)


state 14

    (10) operationi -> PLUS .

    PONTO           reduce using rule 10 (operationi -> PLUS .)
    $end            reduce using rule 10 (operationi -> PLUS .)


state 15

    (11) operationi -> MINUS .

    PONTO           reduce using rule 11 (operationi -> MINUS .)
    $end            reduce using rule 11 (operationi -> MINUS .)


state 16

    (12) operationi -> TIMES .

    PONTO           reduce using rule 12 (operationi -> TIMES .)
    $end            reduce using rule 12 (operationi -> TIMES .)


state 17

    (13) operationi -> DIVIDE .

    PONTO           reduce using rule 13 (operationi -> DIVIDE .)
    $end            reduce using rule 13 (operationi -> DIVIDE .)


state 18

    (14) operationi -> MOD .

    PONTO           reduce using rule 14 (operationi -> MOD .)
    $end            reduce using rule 14 (operationi -> MOD .)


state 19

    (7) expression -> int float operationf .

    PONTO           reduce using rule 7 (expression -> int float operationf .)
    $end            reduce using rule 7 (expression -> int float operationf .)


state 20

    (15) operationf -> PLUS .

    PONTO           reduce using rule 15 (operationf -> PLUS .)
    $end            reduce using rule 15 (operationf -> PLUS .)


state 21

    (16) operationf -> MINUS .

    PONTO           reduce using rule 16 (operationf -> MINUS .)
    $end            reduce using rule 16 (operationf -> MINUS .)


state 22

    (17) operationf -> TIMES .

    PONTO           reduce using rule 17 (operationf -> TIMES .)
    $end            reduce using rule 17 (operationf -> TIMES .)


state 23

    (18) operationf -> DIVIDE .

    PONTO           reduce using rule 18 (operationf -> DIVIDE .)
    $end            reduce using rule 18 (operationf -> DIVIDE .)


state 24

    (5) expression -> float float operationf .

    PONTO           reduce using rule 5 (expression -> float float operationf .)
    $end            reduce using rule 5 (expression -> float float operationf .)


state 25

    (6) expression -> float int operationf .

    PONTO           reduce using rule 6 (expression -> float int operationf .)
    $end            reduce using rule 6 (expression -> float int operationf .)

